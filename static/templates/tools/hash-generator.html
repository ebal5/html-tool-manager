<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ハッシュ生成</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        .panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .input-section {
            margin-bottom: 20px;
        }
        .input-section h2 {
            font-size: 1rem;
            color: #666;
            margin-bottom: 10px;
        }
        textarea {
            width: 100%;
            height: 120px;
            font-family: inherit;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 12px;
            resize: vertical;
        }
        textarea:focus {
            outline: none;
            border-color: #007bff;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background: #0056b3;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .results {
            margin-top: 20px;
        }
        .hash-result {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .hash-label {
            width: 100px;
            font-weight: bold;
            color: #333;
            flex-shrink: 0;
        }
        .hash-value {
            flex: 1;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 12px;
            word-break: break-all;
            padding: 0 10px;
        }
        .hash-copy {
            padding: 6px 12px;
            font-size: 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            flex-shrink: 0;
        }
        .hash-copy:hover {
            background: #218838;
        }
        .hash-copy.copied {
            background: #6c757d;
        }
        .format-options {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        .format-option {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }
        .message {
            padding: 10px;
            border-radius: 4px;
            margin-top: 15px;
            text-align: center;
            background: #d4edda;
            color: #155724;
        }
        .empty-state {
            text-align: center;
            padding: 30px;
            color: #666;
            background: #f8f9fa;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>ハッシュ生成</h1>

    <div class="panel">
        <div class="input-section">
            <h2>入力テキスト</h2>
            <textarea id="input" placeholder="ハッシュ化するテキストを入力..."></textarea>
        </div>

        <div class="format-options">
            <label class="format-option">
                <input type="radio" name="format" value="hex" checked>
                16進数（小文字）
            </label>
            <label class="format-option">
                <input type="radio" name="format" value="HEX">
                16進数（大文字）
            </label>
            <label class="format-option">
                <input type="radio" name="format" value="base64">
                Base64
            </label>
        </div>

        <div class="controls">
            <button class="btn-primary" onclick="generateHashes()">ハッシュ生成</button>
            <button class="btn-secondary" onclick="clearAll()">クリア</button>
        </div>

        <div class="results" id="results">
            <div class="empty-state">テキストを入力して「ハッシュ生成」をクリックしてください</div>
        </div>

        <div id="message" class="message" style="display: none;"></div>
    </div>

    <script>
        const hashAlgorithms = [
            { name: 'MD5', algorithm: 'MD5' },
            { name: 'SHA-1', algorithm: 'SHA-1' },
            { name: 'SHA-256', algorithm: 'SHA-256' },
            { name: 'SHA-384', algorithm: 'SHA-384' },
            { name: 'SHA-512', algorithm: 'SHA-512' }
        ];

        let currentHashes = {};

        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.style.display = 'block';
            setTimeout(() => {
                msg.style.display = 'none';
            }, 2000);
        }

        async function generateHash(text, algorithm) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);

            // MD5はWeb Crypto APIでサポートされていないため、別途実装
            if (algorithm === 'MD5') {
                return md5(text);
            }

            const hashBuffer = await crypto.subtle.digest(algorithm, data);
            return hashBuffer;
        }

        function formatHash(buffer, format) {
            const hashArray = Array.from(new Uint8Array(buffer));

            if (format === 'base64') {
                return btoa(String.fromCharCode.apply(null, hashArray));
            }

            const hex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return format === 'HEX' ? hex.toUpperCase() : hex;
        }

        async function generateHashes() {
            const text = document.getElementById('input').value;
            if (!text) {
                showMessage('テキストを入力してください');
                return;
            }

            const format = document.querySelector('input[name="format"]:checked').value;
            const results = document.getElementById('results');
            results.innerHTML = '';

            for (const algo of hashAlgorithms) {
                try {
                    const hashBuffer = await generateHash(text, algo.algorithm);
                    const hashString = typeof hashBuffer === 'string'
                        ? (format === 'HEX' ? hashBuffer.toUpperCase() : format === 'base64' ? btoa(hexToBytes(hashBuffer).reduce((s, b) => s + String.fromCharCode(b), '')) : hashBuffer)
                        : formatHash(hashBuffer, format);

                    currentHashes[algo.name] = hashString;

                    const div = document.createElement('div');
                    div.className = 'hash-result';
                    div.innerHTML = `
                        <span class="hash-label">${algo.name}</span>
                        <span class="hash-value">${hashString}</span>
                        <button class="hash-copy" onclick="copyHash('${algo.name}', this)">コピー</button>
                    `;
                    results.appendChild(div);
                } catch (error) {
                    console.error(`Error generating ${algo.name}:`, error);
                }
            }

            showMessage('ハッシュを生成しました');
        }

        function hexToBytes(hex) {
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            return bytes;
        }

        function copyHash(name, button) {
            const hash = currentHashes[name];
            if (!hash) return;

            navigator.clipboard.writeText(hash).then(() => {
                button.textContent = 'コピー済';
                button.classList.add('copied');
                setTimeout(() => {
                    button.textContent = 'コピー';
                    button.classList.remove('copied');
                }, 1500);
            });
        }

        function clearAll() {
            document.getElementById('input').value = '';
            document.getElementById('results').innerHTML = '<div class="empty-state">テキストを入力して「ハッシュ生成」をクリックしてください</div>';
            currentHashes = {};
        }

        // フォーマット変更時に再生成
        document.querySelectorAll('input[name="format"]').forEach(input => {
            input.addEventListener('change', () => {
                if (document.getElementById('input').value) {
                    generateHashes();
                }
            });
        });

        // MD5実装（Web Crypto APIでサポートされていないため）
        function md5(string) {
            function rotateLeft(lValue, iShiftBits) {
                return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
            }

            function addUnsigned(lX, lY) {
                const lX4 = lX & 0x40000000;
                const lY4 = lY & 0x40000000;
                const lX8 = lX & 0x80000000;
                const lY8 = lY & 0x80000000;
                const lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
                if (lX4 & lY4) return lResult ^ 0x80000000 ^ lX8 ^ lY8;
                if (lX4 | lY4) {
                    if (lResult & 0x40000000) return lResult ^ 0xC0000000 ^ lX8 ^ lY8;
                    return lResult ^ 0x40000000 ^ lX8 ^ lY8;
                }
                return lResult ^ lX8 ^ lY8;
            }

            function f(x, y, z) { return (x & y) | (~x & z); }
            function g(x, y, z) { return (x & z) | (y & ~z); }
            function h(x, y, z) { return x ^ y ^ z; }
            function i(x, y, z) { return y ^ (x | ~z); }

            function ff(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(f(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function gg(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(g(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function hh(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(h(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function ii(a, b, c, d, x, s, ac) {
                a = addUnsigned(a, addUnsigned(addUnsigned(i(b, c, d), x), ac));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function convertToWordArray(string) {
                let lWordCount;
                const lMessageLength = string.length;
                const lNumberOfWords_temp1 = lMessageLength + 8;
                const lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
                const lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
                const lWordArray = new Array(lNumberOfWords - 1);
                let lBytePosition = 0;
                let lByteCount = 0;
                while (lByteCount < lMessageLength) {
                    lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                    lBytePosition = (lByteCount % 4) * 8;
                    lWordArray[lWordCount] = (lWordArray[lWordCount] || 0) | (string.charCodeAt(lByteCount) << lBytePosition);
                    lByteCount++;
                }
                lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                lBytePosition = (lByteCount % 4) * 8;
                lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
                lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
                lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
                return lWordArray;
            }

            function wordToHex(lValue) {
                let wordToHexValue = '', wordToHexValue_temp = '', lByte, lCount;
                for (lCount = 0; lCount <= 3; lCount++) {
                    lByte = (lValue >>> (lCount * 8)) & 255;
                    wordToHexValue_temp = '0' + lByte.toString(16);
                    wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
                }
                return wordToHexValue;
            }

            function utf8Encode(string) {
                string = string.replace(/\r\n/g, '\n');
                let utftext = '';
                for (let n = 0; n < string.length; n++) {
                    const c = string.charCodeAt(n);
                    if (c < 128) {
                        utftext += String.fromCharCode(c);
                    } else if (c > 127 && c < 2048) {
                        utftext += String.fromCharCode((c >> 6) | 192);
                        utftext += String.fromCharCode((c & 63) | 128);
                    } else {
                        utftext += String.fromCharCode((c >> 12) | 224);
                        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }
                }
                return utftext;
            }

            const S11 = 7, S12 = 12, S13 = 17, S14 = 22;
            const S21 = 5, S22 = 9, S23 = 14, S24 = 20;
            const S31 = 4, S32 = 11, S33 = 16, S34 = 23;
            const S41 = 6, S42 = 10, S43 = 15, S44 = 21;

            string = utf8Encode(string);
            const x = convertToWordArray(string);
            let a = 0x67452301, b = 0xEFCDAB89, c = 0x98BADCFE, d = 0x10325476;

            for (let k = 0; k < x.length; k += 16) {
                const AA = a, BB = b, CC = c, DD = d;
                a = ff(a, b, c, d, x[k], S11, 0xD76AA478);
                d = ff(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
                c = ff(c, d, a, b, x[k + 2], S13, 0x242070DB);
                b = ff(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
                a = ff(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
                d = ff(d, a, b, c, x[k + 5], S12, 0x4787C62A);
                c = ff(c, d, a, b, x[k + 6], S13, 0xA8304613);
                b = ff(b, c, d, a, x[k + 7], S14, 0xFD469501);
                a = ff(a, b, c, d, x[k + 8], S11, 0x698098D8);
                d = ff(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
                c = ff(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
                b = ff(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
                a = ff(a, b, c, d, x[k + 12], S11, 0x6B901122);
                d = ff(d, a, b, c, x[k + 13], S12, 0xFD987193);
                c = ff(c, d, a, b, x[k + 14], S13, 0xA679438E);
                b = ff(b, c, d, a, x[k + 15], S14, 0x49B40821);
                a = gg(a, b, c, d, x[k + 1], S21, 0xF61E2562);
                d = gg(d, a, b, c, x[k + 6], S22, 0xC040B340);
                c = gg(c, d, a, b, x[k + 11], S23, 0x265E5A51);
                b = gg(b, c, d, a, x[k], S24, 0xE9B6C7AA);
                a = gg(a, b, c, d, x[k + 5], S21, 0xD62F105D);
                d = gg(d, a, b, c, x[k + 10], S22, 0x2441453);
                c = gg(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
                b = gg(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
                a = gg(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
                d = gg(d, a, b, c, x[k + 14], S22, 0xC33707D6);
                c = gg(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
                b = gg(b, c, d, a, x[k + 8], S24, 0x455A14ED);
                a = gg(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
                d = gg(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
                c = gg(c, d, a, b, x[k + 7], S23, 0x676F02D9);
                b = gg(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
                a = hh(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
                d = hh(d, a, b, c, x[k + 8], S32, 0x8771F681);
                c = hh(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
                b = hh(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
                a = hh(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
                d = hh(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
                c = hh(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
                b = hh(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
                a = hh(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
                d = hh(d, a, b, c, x[k], S32, 0xEAA127FA);
                c = hh(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
                b = hh(b, c, d, a, x[k + 6], S34, 0x4881D05);
                a = hh(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
                d = hh(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
                c = hh(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
                b = hh(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
                a = ii(a, b, c, d, x[k], S41, 0xF4292244);
                d = ii(d, a, b, c, x[k + 7], S42, 0x432AFF97);
                c = ii(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
                b = ii(b, c, d, a, x[k + 5], S44, 0xFC93A039);
                a = ii(a, b, c, d, x[k + 12], S41, 0x655B59C3);
                d = ii(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
                c = ii(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
                b = ii(b, c, d, a, x[k + 1], S44, 0x85845DD1);
                a = ii(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
                d = ii(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
                c = ii(c, d, a, b, x[k + 6], S43, 0xA3014314);
                b = ii(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
                a = ii(a, b, c, d, x[k + 4], S41, 0xF7537E82);
                d = ii(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
                c = ii(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
                b = ii(b, c, d, a, x[k + 9], S44, 0xEB86D391);
                a = addUnsigned(a, AA);
                b = addUnsigned(b, BB);
                c = addUnsigned(c, CC);
                d = addUnsigned(d, DD);
            }

            return (wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d)).toLowerCase();
        }
    </script>
</body>
</html>
